<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Para Tinita</title>
    <style>
        /* --- CONFIGURACIÓN GENERAL --- */
        :root {
            --env-color-main: #d81b60;
            --env-color-flap: #f06292;
            --seal-color: #b71c1c;
            --bg-color: #fce4ec;
            --text-color: #ad1457;
        }

        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--bg-color);
            background-image: radial-gradient(#f8bbd0 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden; /* Importante para que no haya scroll con los fuegos artificiales */
        }

        /* --- ESTILOS DEL SOBRE (Versión Bonita) --- */
        #envelope-container {
            position: relative;
            cursor: pointer;
            z-index: 20;
            animation: float 3s ease-in-out infinite;
        }

        #envelope-container.opening-active { animation: none; }
        #envelope-container.fade-out { animation: slideDownFadeOut 1s forwards ease-in-out; }

        .envelope {
            width: 320px;
            height: 220px;
            background: linear-gradient(to bottom right, var(--env-color-main), #ad1457);
            position: relative;
            border-radius: 8px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.3), 0 5px 15px rgba(0,0,0,0.2);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .envelope::after {
            content: '';
            position: absolute;
            top: 0; left: 0;
            border-left: 160px solid transparent;
            border-right: 160px solid transparent;
            border-top: 110px solid var(--env-color-flap);
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));
            transform-origin: top;
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1), border-top-color 0.8s;
            z-index: 11;
        }

        .envelope.open::after {
            transform: rotateX(180deg);
            border-top-color: #ec407a;
        }

        .heart-seal {
            position: absolute;
            top: 85px;
            width: 50px; height: 50px;
            background: var(--seal-color);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            color: #ffcdd2; font-size: 24px; z-index: 12;
            border: 3px solid #e57373;
            box-shadow: inset 0 3px 5px rgba(0,0,0,0.3), 0 5px 10px rgba(0,0,0,0.3);
            transition: all 0.5s ease;
        }

        .envelope.open .heart-seal { opacity: 0; transform: scale(0.5); }
        .text-hint { position: absolute; bottom: -50px; width: 100%; text-align: center; color: var(--text-color); font-weight: bold; transition: opacity 0.5s; }
        .envelope.open ~ .text-hint { opacity: 0; }

        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
        @keyframes slideDownFadeOut { to { opacity: 0; transform: translateY(100px) scale(0.9); } }

        /* --- ESTILOS DEL JUEGO --- */
        #game-container {
            display: none;
            flex-direction: column; align-items: center;
            animation: fadeInScale 1.2s forwards;
        }

        h2 { color: var(--env-color-main); margin-bottom: 15px; text-align: center;}
        .puzzle-board {
            width: 300px; height: 300px;
            display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr);
            gap: 3px; border: 5px solid #fff; border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15); background-color: #fff;
        }
        .puzzle-piece {
            width: 100%; height: 100%; background-size: 300px 300px;
            cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; border-radius: 2px;
        }
        .puzzle-piece.selected { transform: scale(0.92); box-shadow: 0 0 15px #ff4081; z-index: 10; border: 3px solid #ff4081; }
        @keyframes fadeInScale { from { opacity: 0; transform: scale(0.8) translateY(30px); } to { opacity: 1; transform: scale(1) translateY(0); } }

        /* --- MENSAJE FINAL Y BOTONES --- */
        #final-message {
            display: none; /* Se activa con Flex */
            position: fixed; /* Fixed para que ocupe toda la pantalla sin scroll */
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(252, 228, 236, 0.98);
            flex-direction: column; justify-content: center; align-items: center;
            text-align: center; z-index: 100;
            padding: 20px; box-sizing: border-box;
        }

        #final-message h1 {
            color: #c2185b; font-size: 2.2rem; margin-bottom: 40px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            z-index: 102; position: relative;
        }

        .buttons-container {
            position: relative;
            width: 100%;
            height: 200px; /* Espacio para que el botón se mueva */
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            z-index: 102;
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.2rem;
            border: none; border-radius: 50px;
            cursor: pointer; font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            transition: transform 0.1s; /* Transición muy rápida para el escape */
        }

        #btn-yes {
            background-color: #e91e63; color: white;
            position: relative; /* Necesario para poder moverlo con top/left luego */
        }

        #btn-no { background-color: #bdbdbd; color: #424242; }

        /* --- FUEGOS ARTIFICIALES --- */
        #fireworks-canvas {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 101; /* Entre el fondo y el texto */
            pointer-events: none; /* Para que no bloquee clicks si algo queda abajo */
            display: none;
        }
        
        /* Mensaje de éxito final */
        #success-overlay {
            display: none;
            position: fixed; top:0; left:0; width:100%; height:100%;
            z-index: 103;
            flex-direction: column; justify-content: center; align-items: center;
            color: #c2185b;
        }
        #success-overlay h1 { font-size: 3em; text-shadow: 0 0 10px white; }

    </style>
</head>
<body>

    <div id="envelope-container" onclick="openEnvelope()">
        <div class="envelope" id="envelope">
            <div class="heart-seal">❤</div>
        </div>
        <div class="text-hint">Toca para abrir</div>
    </div>

    <div id="game-container">
        <h2>Arme el puzzle, a ver si con la práctica que tiene puede :P...</h2>
        <div class="puzzle-board" id="board"></div>
        <p style="color: var(--text-color); margin-top: 15px;">Toca dos piezas para intercambiarlas</p>
    </div>

    <div id="final-message">
        <h1>¿Quieres ser mi Valentín, Tinita? ❤️</h1>
        <div class="buttons-container" id="btns-container">
            <button class="btn" id="btn-yes">SÍ</button>
            <button class="btn" id="btn-no">NO</button>
        </div>
    </div>

    <canvas id="fireworks-canvas"></canvas>
    <div id="success-overlay">
        <h1>¡SÍÍÍÍÍ! ❤️</h1>
        <p>Le amo, pu.. La espero en nuestro refugio :)</p>
    </div>


    <script>
        /* --- CONFIGURACIÓN --- */
        // ¡PON TU FOTO AQUÍ!
        const imageSrc = 'misalsa.jpg'; 
        
        const rows = 3;
        const cols = 3;
        let pieces = [];
        let selectedPiece = null;

        // --- FUNCIONES DEL SOBRE Y PUZZLE (Igual que la versión anterior) ---
        function openEnvelope() {
            const envelope = document.getElementById('envelope');
            const container = document.getElementById('envelope-container');
            container.classList.add('opening-active');
            envelope.classList.add('open');
            setTimeout(() => container.classList.add('fade-out'), 600);
            setTimeout(() => {
                container.style.display = 'none';
                document.getElementById('game-container').style.display = 'flex';
                initGame();
            }, 1400);
        }

        function initGame() {
            const board = document.getElementById('board');
            board.innerHTML = '';
            pieces = [];
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    let piece = document.createElement('div');
                    piece.classList.add('puzzle-piece');
                    piece.style.backgroundImage = `url(${imageSrc})`;
                    piece.style.backgroundPosition = `-${x * 100}px -${y * 100}px`;
                    piece.dataset.correctX = x;
                    piece.dataset.correctY = y;
                    piece.addEventListener('click', () => handlePieceClick(piece));
                    pieces.push(piece);
                }
            }
            shufflePieces(pieces);
            pieces.forEach(piece => board.appendChild(piece));
        }

        function shufflePieces(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function handlePieceClick(piece) {
            if (!selectedPiece) {
                selectedPiece = piece;
                piece.classList.add('selected');
            } else {
                swapPieces(selectedPiece, piece);
                selectedPiece.classList.remove('selected');
                selectedPiece = null;
                checkWin();
            }
        }

        function swapPieces(piece1, piece2) {
            const parent = piece1.parentNode;
            const next1 = piece1.nextSibling;
            const next2 = piece2.nextSibling;
            if (next1 === piece2) parent.insertBefore(piece2, piece1);
            else { parent.insertBefore(piece2, piece1); parent.insertBefore(piece1, next2); }
        }

        function checkWin() {
            const currentPieces = document.querySelectorAll('.puzzle-piece');
            let isWin = true;
            currentPieces.forEach((piece, index) => {
                if (parseInt(piece.dataset.correctX) !== index % cols || parseInt(piece.dataset.correctY) !== Math.floor(index / cols)) isWin = false;
            });
            if (isWin) {
                setTimeout(() => {
                    document.getElementById('final-message').style.display = 'flex';
                    // Iniciar comportamiento de botones
                    initButtons();
                }, 500);
            }
        }

        /* --- LÓGICA DE LOS BOTONES SÍ/NO --- */
        function initButtons() {
            const btnYes = document.getElementById('btn-yes');
            const btnNo = document.getElementById('btn-no');
            const container = document.getElementById('btns-container');

            // Comportamiento del NO
            btnNo.addEventListener('click', () => {
                alert("Esta opción fue deshabilitada por el noni hater");
            });

            // Comportamiento del SÍ (Escapista)
            // Usamos mouseover para PC y touchstart para móvil para que intente escapar antes del click
            ['mouseover', 'touchstart'].forEach(evt => {
                 btnYes.addEventListener(evt, (e) => {
                    // Un pequeño truco: si se mueve muy rápido, el evento de click a veces gana al de movimiento.
                    // Pero la mayoría de las veces se escapará.
                    
                    const containerRect = container.getBoundingClientRect();
                    const btnRect = btnYes.getBoundingClientRect();

                    // Calcular límites dentro del contenedor
                    const maxX = containerRect.width - btnRect.width;
                    const maxY = containerRect.height - btnRect.height;
                    
                    // Generar nueva posición aleatoria
                    const newX = Math.random() * maxX;
                    const newY = Math.random() * maxY;

                    // Aplicar movimiento. Cambiamos a absolute para moverlo libremente dentro del contenedor relativo.
                    btnYes.style.position = 'absolute';
                    // Restamos la posición inicial del contenedor para que las coordenadas sean relativas a él
                    btnYes.style.left = newX + 'px';
                    btnYes.style.top = newY + 'px';
                }, { passive: true }); // passive true ayuda al rendimiento en scroll movil
            });

            // Comportamiento si LOGRA atrapar el SÍ
            btnYes.addEventListener('click', () => {
                // Ocultar la pregunta y botones
                document.getElementById('final-message').style.display = 'none';
                // Mostrar mensaje final y fuegos artificiales
                document.getElementById('success-overlay').style.display = 'flex';
                startFireworks();
            });
        }


        /* --- LÓGICA DE FUEGOS ARTIFICIALES (Canvas puro) --- */
        function startFireworks() {
            const canvas = document.getElementById('fireworks-canvas');
            canvas.style.display = 'block';
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            let particles = [];

            function Particle(x, y, color) {
                this.x = x; this.y = y;
                this.color = color;
                this.radius = Math.random() * 3 + 1;
                this.velocity = {
                    x: (Math.random() - 0.5) * 8,
                    y: (Math.random() - 0.5) * 8
                };
                this.alpha = 1;
                this.friction = 0.95;
                this.gravity = 0.05;
            }
            Particle.prototype.draw = function() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.restore();
            }
            Particle.prototype.update = function() {
                this.velocity.x *= this.friction;
                this.velocity.y *= this.friction;
                this.velocity.y += this.gravity;
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha -= 0.01;
            }

            function createFirework(x, y) {
                const colors = ['#ff4081', '#e91e63', '#ffeb3b', '#00e676', '#2979ff'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                for (let i = 0; i < 50; i++) {
                    particles.push(new Particle(x, y, color));
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                ctx.fillStyle = 'rgba(252, 228, 236, 0.1)'; // Rastro suave
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                particles.forEach((particle, i) => {
                    if (particle.alpha > 0) {
                        particle.update();
                        particle.draw();
                    } else {
                        particles.splice(i, 1);
                    }
                });

                // Lanzar fuegos artificiales aleatoriamente
                if (Math.random() < 0.05) {
                    createFirework(Math.random() * canvas.width, Math.random() * canvas.height / 2);
                }
            }
            
            // Lanzar un par al inicio al centro
            createFirework(canvas.width / 2, canvas.height / 3);
            setTimeout(() => createFirework(canvas.width / 2, canvas.height / 4), 500);
            
            animate();

            // Redimensionar si gira la pantalla
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        }
    </script>
</body>
</html>
